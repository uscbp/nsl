package nslc.src;/* Generated By:JJTree: Do not edit this line. nslc.src.ASTNslLocalVariableDeclaration.java */

/* SCCS  %W--- %G% -- %U% */

// Copyright: Copyright (c) 1997-2002 University of Southern California Brain Project.
// Copyright: This software may be freely copied provided the toplevel
// Copyright: COPYRIGHT file is included with each such copy.
// Copyright: Email nsl@java.usc.edu.

// Author: Salvador Marmol

public class ASTNslLocalVariableDeclaration extends ASTNslFieldDeclaration
{

    private static String endLine = System.getProperty("line.separator");

    public ASTNslLocalVariableDeclaration(int id)
    {
        super(id);
    }

    public ASTNslLocalVariableDeclaration(NslParser p, int id)
    {
        super(p, id);
    }


    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(NslParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }

    public String toJava(NslScope scope)
    {

        String qual = ((getQualifiers().length() == 0) ? "" : (getQualifiers() + ' '));
        String type = getType();
        String vars[] = getVariables();
        String args[] = getArguments();
        String init[] = getVariableInitializer();

        String nslArg;
        StringBuilder code = new StringBuilder("");
        String comma;

        String sufix = getIndentation(first);
        for (int i = 0; i < vars.length; i++)
        {
            if (isNslType)
            {
                comma = ((args[i].length() > 0) ? ", " : "");
                nslArg = scope.isNslType(type) ? "" : (new StringBuilder("").append('\"').append(vars[i]).append('\"').append(", this").append(comma).toString());
                code.append(qual);
                code.append(type);
                code.append(' ');
                code.append(vars[i]);
                code.append(" = new ");
                code.append(type);
                code.append('(');
                code.append(nslArg);
                code.append(args[i]);
                code.append(");");
                code.append(endLine);
                code.append(sufix);
                if (init[i] != null)
                {
                    code.append(vars[i]);
                    code.append(".set(");
                    code.append(init[i]);
                    code.append(");");
                    code.append(endLine);
                    code.append(sufix);
                }
            }
            else
            {
                code.append(qual);
                code.append(type);
                code.append(getTypeSuffix(i));
                code.append(' ');
                code.append(vars[i]);
                code.append(" = new ");
                code.append(type);
                code.append('(');
                code.append(args[i]);
                code.append(");");
                code.append(endLine);
                code.append(sufix);
            }
        }

        first.image = code.toString();
        first.next = last.next.next;

        return code.toString();
    }

    public String getQualifiers()
    {
        String qual = "";
        SimpleNode node = (SimpleNode) jjtGetChild(0);

        Token t = first;
        Token end = node.getFirstToken();

        while (t != end)
        {
            qual += t.image + " ";
            t = t.next;
        }
        return qual;
    }

    public String toXMLOpen(String prefix)
    {
        String modifiers = getQualifiers();
        return prefix + "<" + toString() + " modifiers=\"" + modifiers + "\">";
    }
}
