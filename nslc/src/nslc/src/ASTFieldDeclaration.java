package nslc.src;/* Generated By:JJTree: Do not edit this line. nslc.src.ASTFieldDeclaration.java */

/* SCCS  %W--- %G% -- %U% */

// Copyright: Copyright (c) 1997-2002 University of Southern California Brain Project.
// Copyright: This software may be freely copied provided the toplevel
// Copyright: COPYRIGHT file is included with each such copy.
// Copyright: Email nsl@java.usc.edu.

// Author: Salvador Marmol

public class ASTFieldDeclaration extends SimpleNode
{
    public ASTFieldDeclaration(int id)
    {
        super(id);
    }

    public ASTFieldDeclaration(NslParser p, int id)
    {
        super(p, id);
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(NslParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }

    public String getQualifiers()
    {
        StringBuilder qual = new StringBuilder("");
        ASTType arg = (ASTType) jjtGetChild(0);

        Token t = first;
        Token end = arg.getFirstToken();

        while (t != end)
        {
            qual.append(t.image);
            t = t.next;
        }
        return qual.toString();
    }

    public String getType()
    {
        ASTType typeNode = (ASTType) jjtGetChild(0);
        return typeNode.getType();
    }

    public String[] getVariables()
    {
        int num = jjtGetNumChildren() - 1;
        String names[] = new String[num];

        ASTVariableDeclarator variable;
        for (int i = 0; i < num; i++)
        {
            variable = (ASTVariableDeclarator) jjtGetChild(i + 1);
            names[i] = variable.getName();
        }
        return names;
    }

    public String[] getTypeSuffixes()
    {
        int num = jjtGetNumChildren() - 1;
        String names[] = new String[num];

        ASTVariableDeclarator variable;
        for (int i = 0; i < num; i++)
        {
            variable = (ASTVariableDeclarator) jjtGetChild(i + 1);
            names[i] = variable.getTypeSuffix();
        }
        return names;
    }

    public String[] getVariableInitializer()
    {
        int num = jjtGetNumChildren() - 1;
        String init[] = new String[num];

        ASTVariableDeclarator variable;
        for (int i = 0; i < num; i++)
        {
            variable = (ASTVariableDeclarator) jjtGetChild(i + 1);
            init[i] = variable.getVariableInitializer();
        }
        return init;
    }

    public void updateScope(NslScope scope)
    {
        String qualifiers = getQualifiers();
        String type = getType();
        String names[] = getVariables();
        String suffixes[] = getTypeSuffixes();
        NslVariable temp;

        String classType = type;
        if (scope.isArray(type))
        {
            classType = classType.substring(0, classType.indexOf("["));
        }
        if (!scope.isPrimitive(classType))
        {
            NslCompiler.parseType(classType, NslCompiler.libraryDir, scope.getImportList());
        }
        for (int i = 0; i < names.length; i++)
        {
            temp = new NslVariable(qualifiers, type + suffixes[i], names[i]);
            if (!scope.addLocalVar(temp))
            {
                ASTVariableDeclarator variable = (ASTVariableDeclarator) jjtGetChild(i + 1);
                NslCompiler.printError("ASTFiledDeclaration", "Variable " + variable.getName() + " was already defined in this scope", variable.getFirstToken().beginLine, variable.getFirstToken().beginColumn);
            }
        }
    }

    public String toXMLOpen(String prefix)
    {
        String qualifiers = (getQualifiers().length() == 0 ? " modifiers=\"" + getQualifiers() + '\"' : "");
        return prefix + '<' + toString() + qualifiers + '>';
    }

}
