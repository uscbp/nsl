package nslc.src;/* Generated By:JJTree: Do not edit this line. nslc.src.ASTRelationalExpression.java */

/* SCCS  %W--- %G% -- %U% */

// Copyright: Copyright (c) 1997-2002 University of Southern California Brain Project.
// Copyright: This software may be freely copied provided the toplevel
// Copyright: COPYRIGHT file is included with each such copy.
// Copyright: Email nsl@java.usc.edu.

// Author: Salvador Marmol

import java.io.PrintStream;

public class ASTRelationalExpression extends ASTExpression
{
    public ASTRelationalExpression(int id)
    {
        super(id);
    }

    public ASTRelationalExpression(NslParser p, int id)
    {
        super(p, id);
    }


    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(NslParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }

    public String getOperator(int child)
    {
        int childNum = jjtGetNumChildren();

        if (childNum < 2)
        {
            return "";
        }

        ASTExpression oper = (ASTExpression) jjtGetChild(child - 1);
        return oper.getLastToken().next.image;
    }

    public static String getNslElemGtrHeader(boolean isNsl, String temp)
    {
        String assign = (isNsl ? ".setReference(" : " = (");
        String get = (isNsl ? ".get(), " : ", ");
        return temp + assign + "NslGtr.eval(" + temp + get;
    }

    public static String getNslElemGeqHeader(boolean isNsl, String temp)
    {
        String assign = (isNsl ? ".setReference(" : " = (");
        String get = (isNsl ? ".get(), " : ", ");
        return temp + assign + "NslGeq.eval(" + temp + get;
    }

    public static String getNslElemLesHeader(boolean isNsl, String temp)
    {
        String assign = (isNsl ? ".setReference(" : " = (");
        String get = (isNsl ? ".get(), " : ", ");
        return temp + assign + "NslLes.eval(" + temp + get;
    }

    public static String getNslElemLeqHeader(boolean isNsl, String temp)
    {
        String assign = (isNsl ? ".setReference(" : " = (");
        String get = (isNsl ? ".get(), " : ", ");
        return temp + assign + "NslLeq.eval(" + temp + get;
    }

    public static String getGtrType()
    {
        return "boolean";
    }

    public static String getGeqType()
    {
        return getGtrType();
    }

    public static String getLesType()
    {
        return getGtrType();
    }

    public static String getLeqType()
    {
        return getGtrType();
    }

    public static boolean canApplyElemGtr(int dim1, int dim2)
    {
        return dim1 == dim2 || dim1 == 0 || dim2 == 0;
    }

    public static boolean canApplyElemGeq(int dim1, int dim2)
    {
        return canApplyElemGtr(dim1, dim2);
    }

    public static boolean canApplyElemLes(int dim1, int dim2)
    {
        return canApplyElemGtr(dim1, dim2);
    }

    public static boolean canApplyElemLeq(int dim1, int dim2)
    {
        return canApplyElemGtr(dim1, dim2);
    }

    public static boolean canApplyElemGtr(String type1, String type2)
    {
        return ((type1.toLowerCase().indexOf("int") >= 0) && (type2.toLowerCase().indexOf("int") >= 0)) ||
                ((type1.toLowerCase().indexOf("float") >= 0) && (type2.toLowerCase().indexOf("float") >= 0)) ||
                ((type1.toLowerCase().indexOf("double") >= 0) && (type2.toLowerCase().indexOf("double") >= 0)) ||
                ((type1.toLowerCase().indexOf("boolean") >= 0) && (type2.toLowerCase().indexOf("boolean") >= 0)) ||
                ((type1.toLowerCase().indexOf("string") >= 0) && (type2.toLowerCase().indexOf("string") >= 0));
    }

    public static boolean canApplyElemGeq(String type1, String type2)
    {
        return canApplyElemGtr(type1, type2);
    }

    public static boolean canApplyElemLes(String type1, String type2)
    {
        return canApplyElemGtr(type1, type2);
    }

    public static boolean canApplyElemLeq(String type1, String type2)
    {
        return canApplyElemGtr(type1, type2);
    }

    public static String getElemGtrType(NslScope scope, String type1, String type2)
    {
        if (scope.getDim(type1) == 0 && scope.getDim(type2) != 0)
        {
            if (scope.isNslType(type2))
            {
                return "NslBoolean" + scope.getDim(type2);
            }
            else
            {
                return "boolean" + type2.substring(type2.indexOf("["));
            }
        }
        else if (scope.getDim(type2) == 0 && scope.getDim(type1) != 0)
        {
            if (scope.isNslType(type1))
            {
                return "NslBoolean" + scope.getDim(type1);
            }
            else
            {
                return "boolean" + type1.substring(type1.indexOf("["));
            }
        }
        else
        {
            if (scope.isNslType(type1) || scope.isNslType(type2))
            {
                return "NslBoolean" + scope.getDim(type1);
            }
            else
            {
                return "boolean" + type1.substring(type1.indexOf("["));
            }
        }
    }

    public static String getElemGeqType(NslScope scope, String type1, String type2)
    {
        return getElemGtrType(scope, type1, type2);
    }

    public static String getElemLesType(NslScope scope, String type1, String type2)
    {
        return getElemGtrType(scope, type1, type2);
    }

    public static String getElemLeqType(NslScope scope, String type1, String type2)
    {
        return getElemGtrType(scope, type1, type2);
    }


    public String getExpressionType()
    {
        int childNum = jjtGetNumChildren();

        if (childNum < 2)
        {
            return super.getExpressionType();
        }
        return expressionType;
    }

    public String toJava(NslScope scope)
    {

        int childNum = jjtGetNumChildren();

        if (childNum < 2)
        {
            return "";
        }

        String type1, type2;
        StringBuilder mults;
        String operator;
        ASTExpression oper;
        int dim1, dim2;
        boolean isArray2, isArray1;

        oper = (ASTExpression) jjtGetChild(0);
        type1 = oper.getExpressionType();
        dim1 = scope.getDim(type1);
        isArray1 = dim1 > 0;
        mults = new StringBuilder(oper.getExpression());

        for (int i = 1; i < childNum; i++)
        {
            oper = (ASTExpression) jjtGetChild(i);
            type2 = oper.getExpressionType();
            dim2 = scope.getDim(type2);
            isArray2 = dim2 > 0;

            operator = getOperator(i);

            if (operator.equals(">"))
            {

                if (((isArray1 || isArray2) && !canApplyElemGtr(type1, type2)))
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", new StringBuilder("").append("Trying to use the \">\" operator with non boolean types: ").append(type1).append(" and ").append(type2).toString(), oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else if (((isArray1 || isArray2) && canApplyElemGtr(dim1, dim2)))
                {
                    type1 = getElemGtrType(scope, type1, type2);
                    dim1 = scope.getDim(type1);
                    isArray1 = dim1 > 0;
                    mults.insert(0,getNslElemGtrHeader(scope.isNslType(type1), scope.getTempName(type1)));
                    mults.append(", ");
                    mults.append(oper.getExpression());
                    mults.append("))");
                }
                else if (isArray1 || isArray2)
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", "Trying to compare wrong dimensions", oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else
                {
                    // Scalar equality
                    String ext1 = "", ext2 = "", wrapStart = "", wrapEnd = "";

                    if (scope.isNslType(type1) || scope.isNslType(type2))
                    {

                        if (scope.isNslType(type1))
                        {
                            ext1 = ".get()";
                        }
                        if (scope.isNslType(type2))
                        {
                            ext2 = ".get()";
                        }

                        //temp = scope.getTempName(type1);
                        //wrapStart = temp + ".setReference(";
                        //wrapEnd   = ")";

                    }//else {
                    // Simple equality
                    type1 = getGtrType();
                    //}
                    dim1 = 0;
                    isArray1 = false;
                    mults.insert(0,wrapStart);
                    mults.append(ext1);
                    mults.append(operator);
                    mults.append(oper.getExpression());
                    mults.append(ext2);
                    mults.append(wrapEnd);
                }

            }
            else if (operator.equals(">="))
            {

                if (((isArray1 || isArray2) && !canApplyElemGeq(type1, type2)))
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", new StringBuilder("").append("Trying to use the \">=\" operator with non boolean types: ").append(type1).append(" and ").append(type2).toString(), oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else if (((isArray1 || isArray2) && canApplyElemGeq(dim1, dim2)))
                {
                    type1 = getElemGeqType(scope, type1, type2);
                    dim1 = scope.getDim(type1);
                    isArray1 = dim1 > 0;
                    mults.insert(0, getNslElemGeqHeader(scope.isNslType(type1), scope.getTempName(type1)));
                    mults.append(", ");
                    mults.append(oper.getExpression());
                    mults.append("))");
                }
                else if (isArray1 || isArray2)
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", "Trying to compare wrong dimensions", oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else
                {
                    // Scalar comparison
                    String ext1 = "", ext2 = "", wrapStart = "", wrapEnd = "";

                    if (scope.isNslType(type1) || scope.isNslType(type2))
                    {

                        if (scope.isNslType(type1))
                        {
                            ext1 = ".get()";
                        }
                        if (scope.isNslType(type2))
                        {
                            ext2 = ".get()";
                        }

                        //temp = scope.getTempName(type1);
                        //wrapStart = temp + ".setReference(";
                        //wrapEnd   = ")";

                    } //else {
                    // Simple comparison
                    type1 = getGeqType();
                    //}
                    dim1 = 0;
                    isArray1 = false;
                    mults.insert(0, wrapStart);
                    mults.append(ext1);
                    mults.append(operator);
                    mults.append(oper.getExpression());
                    mults.append(ext2);
                    mults.append(wrapEnd);
                }

            }
            else if (operator.equals("<"))
            {

                if (((isArray1 || isArray2) && !canApplyElemLes(type1, type2)))
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", new StringBuilder("").append("Trying to use the \"<\" operator with non boolean types: ").append(type1).append(" and ").append(type2).toString(), oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else if (((isArray1 || isArray2) && canApplyElemLes(dim1, dim2)))
                {
                    type1 = getElemLesType(scope, type1, type2);
                    dim1 = scope.getDim(type1);
                    isArray1 = dim1 > 0;
                    mults.insert(0,getNslElemLesHeader(scope.isNslType(type1), scope.getTempName(type1)));
                    mults.append(", ");
                    mults.append(oper.getExpression());
                    mults.append("))");
                }
                else if (isArray1 || isArray2)
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", "Trying to compare wrong dimensions", oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else
                {
                    // Scalar comparison
                    String ext1 = "", ext2 = "", wrapStart = "", wrapEnd = "";

                    if (scope.isNslType(type1) || scope.isNslType(type2))
                    {

                        if (scope.isNslType(type1))
                        {
                            ext1 = ".get()";
                        }
                        if (scope.isNslType(type2))
                        {
                            ext2 = ".get()";
                        }

                        //temp = scope.getTempName(type1);
                        //wrapStart = temp + ".setReference(";
                        //wrapEnd   = ")";

                    } //else {
                    // Simple comparison
                    type1 = getLesType();
                    //}
                    dim1 = 0;
                    isArray1 = false;
                    mults.insert(0,wrapStart);
                    mults.append(ext1);
                    mults.append(operator);
                    mults.append(oper.getExpression());
                    mults.append(ext2);
                    mults.append(wrapEnd);
                }

            }
            else if (operator.equals("<="))
            {

                if (((isArray1 || isArray2) && !canApplyElemLeq(type1, type2)))
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", new StringBuilder("").append("Trying to use the \"<=\" operator with non boolean types: ").append(type1).append(" and ").append(type2).toString(), oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else if (((isArray1 || isArray2) && canApplyElemLeq(dim1, dim2)))
                {
                    type1 = getElemLeqType(scope, type1, type2);
                    dim1 = scope.getDim(type1);
                    isArray1 = dim1 > 0;
                    mults.insert(0,getNslElemLeqHeader(scope.isNslType(type1), scope.getTempName(type1)));
                    mults.append(", ");
                    mults.append(oper.getExpression());
                    mults.append("))");
                }
                else if (isArray1 || isArray2)
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", "Trying to compare wrong dimensions", oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else
                {
                    // Scalar comparison
                    String ext1 = "", ext2 = "", wrapStart = "", wrapEnd = "";

                    if (scope.isNslType(type1) || scope.isNslType(type2))
                    {

                        if (scope.isNslType(type1))
                        {
                            ext1 = ".get()";
                        }
                        if (scope.isNslType(type2))
                        {
                            type1 = type2;
                            ext2 = ".get()";
                        }

                        //temp = scope.getTempName(type1);
                        //wrapStart = temp + ".setReference(";
                        //wrapEnd   = ")";

                    } //else {
                    // Simple comparison
                    type1 = getLeqType();
                    //}
                    dim1 = 0;
                    isArray1 = false;
                    mults.insert(0,wrapStart);
                    mults.append(ext1);
                    mults.append(operator);
                    mults.append(oper.getExpression());
                    mults.append(ext2);
                    mults.append(wrapEnd);
                }
            }
        }

        expressionType = type1;

        first.image = mults.toString();
        last.image = "";
        first.next = last;

        return "";
    }


    public String computeType(NslScope scope)
    {

        int childNum = jjtGetNumChildren();

        if (childNum < 2)
        {
            return "";
        }

        String type1, type2;
        String operator;
        ASTExpression oper;
        int dim1, dim2;
        boolean isArray2, isArray1;

        oper = (ASTExpression) jjtGetChild(0);
        type1 = oper.getExpressionType();
        dim1 = scope.getDim(type1);
        isArray1 = dim1 > 0;

        for (int i = 1; i < childNum; i++)
        {
            oper = (ASTExpression) jjtGetChild(i);
            type2 = oper.getExpressionType();
            dim2 = scope.getDim(type2);
            isArray2 = dim2 > 0;

            operator = getOperator(i);

            if (operator.equals(">"))
            {

                if (((isArray1 || isArray2) && !canApplyElemGtr(type1, type2)))
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", new StringBuilder("").append("Trying to use the \">\" operator with non boolean types: ").append(type1).append(" and ").append(type2).toString(), oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else if (((isArray1 || isArray2) && canApplyElemGtr(dim1, dim2)))
                {
                    type1 = getElemGtrType(scope, type1, type2);
                    dim1 = scope.getDim(type1);
                    isArray1 = dim1 > 0;
                }
                else if (isArray1 || isArray2)
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", "Trying to compare wrong dimensions", oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else
                {
                    // Scalar equality
                    type1 = getGtrType();
                    dim1 = 0;
                    isArray1 = false;
                }

            }
            else if (operator.equals(">="))
            {

                if (((isArray1 || isArray2) && !canApplyElemGeq(type1, type2)))
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", new StringBuilder("").append("Trying to use the \">=\" operator with non boolean types: ").append(type1).append(" and ").append(type2).toString(), oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else if (((isArray1 || isArray2) && canApplyElemGeq(dim1, dim2)))
                {
                    type1 = getElemGeqType(scope, type1, type2);
                    dim1 = scope.getDim(type1);
                    isArray1 = dim1 > 0;
                }
                else if (isArray1 || isArray2)
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", "Trying to compare wrong dimensions", oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else
                {
                    // Scalar comparison
                    type1 = getGeqType();
                    dim1 = 0;
                    isArray1 = false;
                }

            }
            else if (operator.equals("<"))
            {

                if (((isArray1 || isArray2) && !canApplyElemLes(type1, type2)))
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", new StringBuilder("").append("Trying to use the \"<\" operator with non boolean types: ").append(type1).append(" and ").append(type2).toString(), oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else if (((isArray1 || isArray2) && canApplyElemLes(dim1, dim2)))
                {
                    type1 = getElemLesType(scope, type1, type2);
                    dim1 = scope.getDim(type1);
                    isArray1 = dim1 > 0;
                }
                else if (isArray1 || isArray2)
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", "Trying to compare wrong dimensions", oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else
                {
                    // Scalar comparison
                    type1 = getLesType();
                    dim1 = 0;
                    isArray1 = false;
                }

            }
            else if (operator.equals("<="))
            {

                if (((isArray1 || isArray2) && !canApplyElemLeq(type1, type2)))
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", new StringBuilder("").append("Trying to use the \"<=\" operator with non boolean types: ").append(type1).append(" and ").append(type2).toString(), oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else if (((isArray1 || isArray2) && canApplyElemLeq(dim1, dim2)))
                {
                    type1 = getElemLeqType(scope, type1, type2);
                    dim1 = scope.getDim(type1);
                    isArray1 = dim1 > 0;
                }
                else if (isArray1 || isArray2)
                {
                    NslCompiler.printError("nslc.src.ASTRelationalExpression", "Trying to compare wrong dimensions", oper.getFirstToken().beginLine, oper.getFirstToken().beginColumn);
                    return "";
                }
                else
                {
                    // Scalar comparison
                    type1 = getLeqType();
                    dim1 = 0;
                    isArray1 = false;
                }
            }
        }

        expressionType = type1;

        return "";
    }

    public void dumpXML(String prefix, PrintStream out)
    {
        String xml = toXMLOpen(prefix);
        if (xml != null)
        {
            out.println(xml);
        }
        if (children != null)
        {
            SimpleNode n = (SimpleNode) children[0];
            if (n != null)
            {
                n.dumpXML(prefix + ' ', out);
            }
            for (int i = 1; i < children.length; ++i)
            {
                n = (SimpleNode) children[i];
                if (n != null)
                {
                    String operator = getOperator(i);
                    if (operator.equals(">"))
                    {
                        operator = "&gt;";
                    }
                    else if (operator.equals(">="))
                    {
                        operator = "&gt;=";
                    }
                    else if (operator.equals("<"))
                    {
                        operator = "&lt;";
                    }
                    else if (operator.equals("<="))
                    {
                        operator = "&lt;=";
                    }
                    xml = new StringBuilder("").append("<Operator>").append(operator).toString();
                    out.println(new StringBuilder("").append(prefix).append(' ').append(xml).toString());
                    xml = "</Operator>";
                    out.println(new StringBuilder("").append(prefix).append(' ').append(xml).toString());
                    n.dumpXML(new StringBuilder("").append(prefix).append(' ').toString(), out);
                }
            }
        }
        xml = toXMLClose(prefix);
        if (xml != null)
        {
            out.println(xml);
        }
    }
}
