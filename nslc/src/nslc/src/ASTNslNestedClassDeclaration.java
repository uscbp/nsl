package nslc.src;/* Generated By:JJTree: Do not edit this line. nslc.src.ASTNslNestedClassDeclaration.java */

/* SCCS  %W--- %G% -- %U% */

// Copyright: Copyright (c) 1997-2002 University of Southern California Brain Project.

// Copyright: This software may be freely copied provided the toplevel

// Copyright: COPYRIGHT file is included with each such copy.

// Copyright: Email nsl@java.usc.edu.

// Author: Salvador Marmol


import java.util.Enumeration;
import java.util.Vector;


public class ASTNslNestedClassDeclaration extends SimpleNode
{
    private boolean implement = false;

    private boolean inherits = false;

    private static String endLine = System.getProperty("line.separator");

    private NslScope localScope = null;


    public ASTNslNestedClassDeclaration(int id)
    {

        super(id);

    }


    public ASTNslNestedClassDeclaration(NslParser p, int id)
    {

        super(p, id);

    }


    /**
     * Accept the visitor. *
     */

    public Object jjtAccept(NslParserVisitor visitor, Object data)
    {

        return visitor.visit(this, data);

    }


    public void setExtends(boolean value)
    {

        inherits = value;

    }


    public boolean getExtends()
    {

        return inherits;

    }


    public void setImplements(boolean value)
    {
        implement = value;
    }

    public boolean getImplements()
    {
        return implement;
    }

    public String[] getInterfaceNames()
    {
        if (implement)
        {
            int index = (inherits ? 2 : 1);
            if(jjtGetChild(index) instanceof ASTNameList)
            {
                ASTNameList node = (ASTNameList) jjtGetChild(index);
                return node.getNames();
            }
        }
        return null;
    }

    public NslScope getLocalScope()
    {

        return localScope;

    }


    public String getSuperClass()
    {

        if (inherits)
        {

            ASTName nameNode = (ASTName) jjtGetChild(1);

            return nameNode.getName();

        }
        else
        {

            return 'N' + getKind().substring(1);

        }

    }


    public String getClassName()
    {

        Token t = first.next;

        return t.image;

    }


    public String getKind()
    {

        Token t = first;

        return t.image;

    }


    public String toJava(NslScope scope)
    {


        StringBuilder code = new StringBuilder("public class ");

        code.append(getClassName());

        code.append(" extends ");
        code.append(getSuperClass());

        String[] interfaceNames=getInterfaceNames();
        if(interfaceNames!=null)
        {
            if(interfaceNames.length>0)
                code.append(" implements ");
            for(int i=0; i<interfaceNames.length; i++)
            {
                if(i>0)
                    code.append(", ");
                code.append(interfaceNames[i]);
            }
        }

        String nslCode = genNslCode(scope);


        first.image = code.toString();


        int bodyIndex = (inherits ? 3 : 1);

        SimpleNode body = (SimpleNode) jjtGetChild(bodyIndex);


        first.next = body.getFirstToken();


        Token newCode = new Token();


        newCode.kind = last.kind;

        newCode.beginLine = last.beginLine;

        newCode.beginColumn = last.beginColumn;

        newCode.endLine = last.endLine;

        newCode.endColumn = last.endColumn;

        newCode.image = last.image;

        newCode.next = last.next;

        newCode.specialToken = last.specialToken;


        last.image = nslCode;

        last.next = newCode;

        //clean(first, end);


        return code.toString();

    }


    String genNslCode(NslScope scope)
    {

        StringBuilder strbuf = new StringBuilder("");

        String prefix = getIndentation(first);

        strbuf.append(endLine);

        strbuf.append(prefix);
        strbuf.append("\t/******************************************************/");
        strbuf.append(endLine);

        strbuf.append(prefix);
        strbuf.append("\t/*                                                    */");
        strbuf.append(endLine);

        strbuf.append(prefix);
        strbuf.append("\t/* Generated by nslc.src.NslCompiler. Do not edit these lines! */");
        strbuf.append(endLine);

        strbuf.append(prefix);
        strbuf.append("\t/*                                                    */");
        strbuf.append(endLine);

        strbuf.append(prefix);
        strbuf.append("\t/******************************************************/");
        strbuf.append(endLine);

        strbuf.append(endLine);

        strbuf.append(genConstructor(localScope));

        strbuf.append(prefix);
        strbuf.append(endLine);

        strbuf.append(prefix).append("\t/******************************************************/").append(endLine);

        strbuf.append(prefix).append("\t/*                                                    */").append(endLine);

        strbuf.append(prefix).append("\t/* End of automatic declaration statements.           */").append(endLine);

        strbuf.append(prefix).append("\t/*                                                    */").append(endLine);

        strbuf.append(prefix).append("\t/******************************************************/").append(endLine);

        strbuf.append(endLine);


        return strbuf.toString();

    }


    static String genTempInstStmt(NslScope scope)
    {


        StringBuilder strbuf = new StringBuilder("");


        Vector tempVarList = scope.getTempVarList();

        Enumeration e = tempVarList.elements();

        NslVariable fieldTmp;

        String instanceType;

        String instanceName;

        String instanceArguments;

        String staticType = "";

        boolean isNsl;


        while (e.hasMoreElements())
        {

            fieldTmp = (NslVariable) e.nextElement();

            instanceType = fieldTmp.getType();

            instanceName = fieldTmp.getName();

            instanceArguments = "";

            if (instanceType.indexOf("static ") >= 0)
            {

                instanceType = instanceType.substring(7);

                staticType = "static ";

            }

            isNsl = scope.isNslType(instanceType);

            if (isNsl)
            {

                instanceType = scope.getNslTypeWithoutPort(instanceType);

                switch (scope.getNslTypeDim(instanceType))
                {

                    case 1:

                        instanceArguments = "1";

                        break;

                    case 2:

                        instanceArguments = "1, 1";

                        break;

                    case 3:

                        instanceArguments = "1, 1, 1";

                        break;

                    case 4:

                        instanceArguments = "1, 1, 1, 1";

                        break;

                }

                strbuf.append("\t\t").append(staticType).append(instanceType).append(' ').append(instanceName).append(" = new ").append(instanceType).append('(').append(instanceArguments).append(");").append(endLine);

            }
            else
            {

                int dim = scope.getDim(instanceType);

                switch (dim)
                {

                    case 1:

                        instanceArguments = "[1]";

                        break;

                    case 2:

                        instanceArguments = "[1][1]";

                        break;

                    case 3:

                        instanceArguments = "[1][1][1]";

                        break;

                    case 4:

                        instanceArguments = "[1][1][1][1]";

                        break;

                }

                if (dim > 0)
                {

                    String newInstanceType = instanceType.substring(0, instanceType.indexOf("["));

                    strbuf.append("\t\t").append(staticType).append(instanceType).append(' ').append(instanceName).append(" = new ").append(newInstanceType).append(instanceArguments).append(';').append(endLine);

                }

            }

        }

        return strbuf.toString();

    }


    static String genTempDeclaration(NslScope scope)
    {


        StringBuilder strbuf = new StringBuilder("");


        Vector tempVarList = scope.getTempVarList();

        Enumeration e = tempVarList.elements();

        NslVariable fieldTmp;

        String instanceType;

        String instanceName;

        while (e.hasMoreElements())
        {

            fieldTmp = (NslVariable) e.nextElement();

            instanceType = fieldTmp.getType();

            instanceName = fieldTmp.getName();

            instanceType = scope.getNslTypeWithoutPort(instanceType);

            strbuf.append('\t').append(instanceType).append(' ').append(instanceName).append(';').append(endLine);

        }

        return strbuf.toString();

    }


    String genConstructor(NslScope scope)
    {


        StringBuilder strbuf = new StringBuilder("");


        strbuf.append("\t/* Constructor and related methods */").append(endLine);

        strbuf.append("\t/* makeinst() declared variables */").append(endLine);

        //String kind = getKind();

        String name = getClassName();

        //String newName = name.substring(0, 1).toLowerCase() + name.substring(1);

        //String superClass = getSuperClass();


        ASTFormalParameters formals = scope.getClassFormals();

        String formalTypes[] = formals.getTypes();

        String formalNames[] = formals.getNames();

        int numFormals = formalTypes.length;


        ASTArguments argumentsNode = scope.getClassArguments();


        String arguments[] = null;

        int numArguments;

        if (argumentsNode != null)
        {

            arguments = argumentsNode.getArguments();

            numArguments = arguments.length;

        }
        else
        {

            numArguments = 0;

        }

        //

        // Formal Declaration

        //


        strbuf.append(endLine);

        strbuf.append("\t/* Formal parameters */").append(endLine);

        //  Add Formals

        for (int i = 0; i < numFormals; i++)
        {

            strbuf.append('\t').append(formalTypes[i]).append(' ').append(formalNames[i]).append(';').append(endLine);

        }

        //

        // Temporary Variables Declaration

        //


        strbuf.append(endLine);

        strbuf.append("\t/* Temporary variables */").append(endLine);

        //  Add Temporaries

        strbuf.append(genTempDeclaration(scope));

        // Constructor


        strbuf.append(endLine);

        strbuf.append("\tpublic ").append(name).append("(String nslName, NslClass nslParent");

        // Add Formals

        for (int i = 0; i < numFormals; i++)
        {

            strbuf.append(", ").append(formalTypes[i]).append(' ').append(formalNames[i]);

        }


        strbuf.append(") {").append(endLine);

        strbuf.append("\t\tsuper(nslName, nslParent");

        // Add Arguments

        for (int i = 0; i < numArguments; i++)
        {

            strbuf.append(", ").append(arguments[i]);

        }


        strbuf.append(");").append(endLine);

        // Add Formals init

        for (int i = 0; i < numFormals; i++)
        {

            strbuf.append("\t\tthis.").append(formalNames[i]).append('=').append(formalNames[i]).append(';').append(endLine);

        }


        strbuf.append("\t\tmakeInst").append(name).append("(nslName, nslParent");

        // Add Arguments

        for (int i = 0; i < numFormals; i++)
        {

            strbuf.append(", ").append(formalNames[i]);

        }


        strbuf.append(");").append(endLine);

        strbuf.append("\t}").append(endLine);

        //

        // MakeInst

        //


        strbuf.append(endLine);

        strbuf.append("\tpublic void makeInst").append(name).append("(String nslName, NslClass nslParent");

        // Add Formals

        for (int i = 0; i < numFormals; i++)
        {

            strbuf.append(", ").append(formalTypes[i]).append(' ').append(formalNames[i]);

        }


        strbuf.append(") { ").append(endLine);

        strbuf.append("\t\tObject[] nslArgs=new Object[]{");
        if(numFormals>0)
        {
            strbuf.append(formalNames[0]);
            for(int i=1; i<numFormals; i++)
            {
                strbuf.append(", ");
                strbuf.append(formalNames[i]);
            }
        }
        strbuf.append("};");
        strbuf.append(endLine);

        strbuf.append("\t\tcallFromConstructorTop(nslArgs);").append(endLine);

        // Put Instantiation of temporaries in makeInst

        strbuf.append(genTempInstStmt(scope));

        // Create Nsl Instances

        Vector classVarScope = scope.getClassVarScope();

        Enumeration e = classVarScope.elements();

        NslVariable fieldTmp;

        String instanceType;

        String instanceName;

        String instanceArguments;

        String variableInit;


        while (e.hasMoreElements())
        {

            fieldTmp = (NslVariable) e.nextElement();

            instanceType = fieldTmp.getType();

            instanceName = fieldTmp.getName();

            instanceArguments = fieldTmp.getArguments();


            if (fieldTmp.isNslType())
            {


                variableInit = fieldTmp.getInitializers();

                instanceArguments = ((instanceArguments != null && instanceArguments.length() != 0) ? (new StringBuilder("").append(", ").append(instanceArguments).toString()) : "");

                strbuf.append("\t\t").append(instanceName).append(" = new ").append(instanceType).append("(\"").append(instanceName).append("\", this").append(instanceArguments).append(");").append(endLine);

                if (variableInit != null)
                {

                    strbuf.append("\t\t").append(instanceName).append(".set(").append(variableInit).append(");").append(endLine);

                }

            }
            else if (fieldTmp.isNslArrayType())
            {

                instanceType = instanceType.substring(0, instanceType.indexOf("["));

                strbuf.append("\t\t").append(instanceName).append(" = new ").append(instanceType).append(instanceArguments).append(';').append(endLine);

            }

        }


        strbuf.append("\t\tcallFromConstructorBottom();").append(endLine);


        strbuf.append("\t}").append(endLine);


        return strbuf.toString();

    }


    public void updateScope(NslScope scope)
    {


        NslScope subClassScope = new NslScope();


        subClassScope.setClassKind(getKind());

        subClassScope.setClassName(getClassName());


        String superClass = getSuperClass();

        subClassScope.setSuperClassName(superClass);


        ASTFormalParameters formals = (ASTFormalParameters) jjtGetChild(0);

        subClassScope.setClassFormals(formals);


        String types[] = formals.getTypes();

        String names[] = formals.getNames();


        NslVariable temp;

        for (int i = 0; i < names.length; i++)
        {

            if (subClassScope.isNslType(types[i]))
            {

                temp = new NslVariable(types[i], names[i]);

                if (!subClassScope.addLocalVar(temp))
                {

                    ASTFormalParameters variable = (ASTFormalParameters) jjtGetChild(i + 1);

                    NslCompiler.printError("nslc.src.ASTNslNestedClassDeclaration", new StringBuilder("").append("Variable ").append(names[i]).append(" was already defined in this scope").toString(), variable.getFirstToken().beginLine, variable.getFirstToken().beginColumn);

                }

            }

        }


        if (inherits)
        {

            subClassScope.setClassArguments((ASTArguments) jjtGetChild(2));

        }


        NslScope superClassScope = NslCompiler.parseType(superClass, NslCompiler.libraryDir, scope.getImportList());

        if (superClassScope != null)
        {

            subClassScope.setSuperClassScope(superClassScope);

        } //else {

        //nslc.src.NslParser.error=true;

        //System.err.println("nslc.src.ASTNestedClassDeclaration [Error]: Error while parsing super class "+superClass);

        //}


        subClassScope.setContainerScope(scope);


        int child = (inherits ? 3 : 1);


        NslParserVisitor visitor = new SymbolTableClassVisitor(subClassScope);

        ASTClassBody node = (ASTClassBody) jjtGetChild(child);

        node.jjtAccept(visitor, null);


        visitor = new SymbolTableVisitor(subClassScope);

        node.jjtAccept(visitor, null);

        localScope = subClassScope;


        scope.addSubClass(subClassScope);

    }


}

