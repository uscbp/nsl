package nslc.src;/* Generated By:JJTree: Do not edit this line. nslc.src.ASTPrimaryExpression.java */

/* SCCS  %W--- %G% -- %U% */

// Copyright: Copyright (c) 1997-2002 University of Southern California Brain Project.
// Copyright: This software may be freely copied provided the toplevel
// Copyright: COPYRIGHT file is included with each such copy.
// Copyright: Email nsl@java.usc.edu.

// Author: Salvador Marmol

public class ASTPrimaryExpression extends ASTExpression
{

    public ASTPrimaryExpression(int id)
    {
        super(id);
    }

    public ASTPrimaryExpression(NslParser p, int id)
    {
        super(p, id);
    }

    public String getExpressionType()
    {
        return expressionType;
    }

    /**
     * Accept the visitor. *
     */
    public Object jjtAccept(NslParserVisitor visitor, Object data)
    {
        return visitor.visit(this, data);
    }

    public static int getNextState(int previousState, String name)
    {
        int nextState = -1;
        switch (previousState)
        {
            case 0: // this
                if (name.equals("access"))
                {
                    nextState = 5;
                }
                else if (name.equals(".super"))
                {
                    nextState = 6;
                }
                break;
            case 1: // super.
                // Super class access
                break;
            case 2: // "(" Expression ")"
                if (name.equals("access"))
                {
                    nextState = 5;
                }
                else if (name.equals("index"))
                {
                    nextState = 9;
                }
                else if (name.equals(".super"))
                {
                    nextState = 6;
                }
                break;
            case 3: // Name
                if (name.equals("index"))
                {
                    nextState = 9;
                }
                else if (name.equals("method"))
                {
                    nextState = 7;
                }
                break;
            case 4: // Index
                if (name.equals("index"))
                {
                    nextState = 4;
                }
                else if (name.equals("access"))
                {
                    nextState = 8;
                }
                break;
            case 5: // Access
                if (name.equals("access"))
                {
                    nextState = 5;
                }
                else if (name.equals("index"))
                {
                    nextState = 9;
                }
                else if (name.equals("method"))
                {
                    nextState = 7;
                }
                break;
            case 6: // .super
                if (name.equals("access"))
                {
                    nextState = 5;
                }
                break;
            case 7: // Method
                if (name.equals("access"))
                {
                    nextState = 5;
                }
                else if (name.equals("index"))
                {
                    nextState = 9;
                }
                break;
            case 8: // construct index
                nextState = 5;
                break;
            case 9: // start index
                nextState = 4;
                break;
        }
        return nextState;
    }

    public void generateIndexCode(Token start, Token end, SimpleNode parentExpression,
                                  ASTPrimarySuffix indexNodes[], int indexNum, NslScope scope, String currentType)
    {

        if (!nslExpression)
        {
            return;
        }

        boolean isAssignment = parentExpression.isNodeOfType("assignment");
        String ext = (isAssignment ? ".set(" : ".get(");

        if (isAssignment)
        {
            start.image += ext;
            indexNodes[0].removeBraces("", ", ");
            for (int j = 1; j < indexNum; j++)
            {
                indexNodes[j].removeBraces("", ", ");
            }
        }
        else
        {
            String wrap = "))";
//      if (scope.getDim(currentType)>0) {
            String temp = scope.getTempName(currentType);
            start.image = temp + ".setReference(" + start.image + ext;
//      } else {
//        start.image = start.image + ext;
//	wrap=")";
//      }
            indexNodes[0].removeBraces("", "");
            for (int j = 1; j < indexNum; j++)
            {
                indexNodes[j].removeBraces(", ", "");
            }
            if (end.image.equals("."))
            {
                end.image = wrap + end.image;
            }
            else
            {
                end.image += wrap;
            }
        }

    }

    public boolean isNslExpression()
    {
        return nslExpression;
    }

    SimpleNode currentOper;

    public String getNewType(NslScope scope, String type, int indexNum)
    {
        if (scope.isNslType(type))
        {
            int dim = scope.getNslTypeDim(type);
            dim = dim - indexNum;
            if (dim >= 0 && dim <= 4)
            {
                type = type.substring(0, type.length() - 1) + dim;
            }
            else
            {
                NslCompiler.printError("nslc.src.ASTPrimaryExpression", "An array is required to use the \"[]\" operator", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
            }
        }
        else if (isArray)
        {
            int dim = scope.getArrayDim(type);
            dim = dim - indexNum;
            if (dim >= 0 && dim <= 4)
            {
                StringBuilder temp = new StringBuilder("");
                for (int i = 0; i < dim; i++)
                {
                    temp.append("[]");
                }
                if(type.indexOf("[")>=0)
                    type = type.substring(0, type.indexOf("[")) + temp;
                else
                    isArray=false;
            }
            else
            {
                NslCompiler.printError("nslc.src.ASTPrimaryExpression", "An array is required to use the \"[]\" operator", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
            }
        }
        return type;
    }

    boolean isArray = false, isMethod = false, isAccess = false;

    public String toJava(NslScope scope)
    {

        int childNum = jjtGetNumChildren();

        ASTPrimaryPrefix prefixNode = (ASTPrimaryPrefix) (currentOper = (SimpleNode) jjtGetChild(0));

        int oldState, state;
        String currentType;

        if (prefixNode.isNodeOfType("this"))
        {
            currentType = expressionType = scope.getClassName();
            isAccess = true;
            state = 0;
        }
        else if (prefixNode.isNodeOfType("super."))
        {
            currentType = expressionType = scope.getSuperClassName();
            isAccess = true;
            state = 1;
        }
        else if (prefixNode.isNodeOfType("expression"))
        {
            currentType = expressionType = prefixNode.getType();
            nslExpression = prefixNode.isNslExpression();
            isArray = scope.isArray(expressionType);
            state = 2;
        }
        else if (prefixNode.isNodeOfType("name"))
        {
            currentType = expressionType = prefixNode.getType();
            nslExpression = prefixNode.isNslExpression();
            isArray = scope.isArray(expressionType);
            isMethod = prefixNode.isMethodName();
            state = 3;
        }
        else if (prefixNode.isNodeOfType("literal"))
        {
            expressionType = prefixNode.getType();
            return "";
        }
        else if (prefixNode.isNodeOfType("allocation"))
        {
            expressionType = prefixNode.getType();
            return "";
        }
        else
        {
            return "";
        }

        if (!nslExpression && !isArray && !isMethod && !isAccess)
        {
            return "";
        }

        SimpleNode parentExpression = findParentExpression((SimpleNode) parent);

        if (parentExpression == null)
        {
            NslCompiler.printError("nslc.src.ASTPrimaryExpression", "Compiler bug. An invalid AST was formed");
            return "";
        }

        if (nslExpression && childNum == 1 && state == 3)
        {
            // A Nsl LHS variable
            String ext = (parentExpression.isNodeOfType("assignment") ? ".set(" : "");
            return first.image = first.image + ext;
        }

        int indexNum = 0;
        ASTPrimarySuffix indexNodes[] = new ASTPrimarySuffix[childNum - 1];
        ASTPrimarySuffix tempNode = null;
        Token start = first, end = last;
        NslScope methodScope = (isMethod ? prefixNode.getMethodScope() : null);
        String methodName = (isMethod ? prefixNode.getMethodName() : null);
        String[] arguments;
        String variableName;
        for (int i = 1; i < childNum; i++)
        {
            currentOper = tempNode = (ASTPrimarySuffix) jjtGetChild(i);
            oldState = state;
            state = getNextState(oldState, tempNode.getNodeType());
            switch (state)
            {
                case -1:
                    NslCompiler.printError("nslc.src.ASTPrimaryExpression", "Invalid state was reached in expression.", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                    return "";
                case 7:
                    if (methodScope != null)
                    {
                        arguments = tempNode.getArgumentsTypes();
                        NslMethod method = methodScope.resolveMethod(methodName, arguments);
                        if (method != null)
                        {
                            currentType = expressionType = method.getType();
                            nslExpression = scope.isNslType(currentType);
                            isArray = scope.isArray(currentType);
                        }
                        else
                        {
                            StringBuilder error = new StringBuilder("Couldn't find method ");
                            error.append(methodScope.getClassName());
                            error.append('.');
                            error.append(methodName);
                            error.append('(');

                            for (int j = 0; j < arguments.length; j++)
                            {
                                error.append(((j > 0) ? ", " : ""));
                                error.append(arguments[j]);
                            }
                            error.append(") in class ");
                            error.append(scope.getClassName());
                            NslCompiler.printError("nslc.src.ASTPrimaryExpression", error.toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        }
                    }
                    else
                    {
                    }
                    break;
                case 8:
                    end = tempNode.getFirstToken();
                    currentType = expressionType = getNewType(scope, currentType, indexNum);
                    generateIndexCode(start, end, parentExpression, indexNodes, indexNum, scope, currentType);
                    state = 5;
                case 5:
                    variableName = tempNode.getVariableName();

                    if (currentType.indexOf("[") >= 0)
                    {
                        if (!variableName.equals("length"))
                        {
                            NslCompiler.printError("nslc.src.ASTPrimaryExpression", new StringBuilder("").append("Type ").append(currentType).append(" is an array. Trying to access something different than length").toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        }
                        else
                        {
                            currentType = expressionType = "int";
                            break;
                        }
                    }
                    NslScope localScope = scope.resolveClass(currentType);
                    if (localScope == null)
                    {
                        NslCompiler.printError("nslc.src.ASTPrimaryExpression", new StringBuilder("").append("Type ").append(currentType).append(" was not found").toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                        return "";
                    }
                    NslVariable temp = localScope.resolveVar(variableName);
                    if (temp == null)
                    {
                        // check if it is a function name
                        NslMethod method = localScope.resolveMethod(variableName);
                        if (method == null)
                        {
                            NslCompiler.printError("nslc.src.ASTPrimaryExpression", new StringBuilder("").append("Variable ").append(variableName).append(" was not found in class ").append(localScope.getClassName()).toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        }
                        else
                        {
                            methodName = variableName;
                            methodScope = localScope;
                            isMethod = true;
                        }
                    }
                    else
                    {
                        currentType = expressionType = temp.getType();
                        nslExpression = scope.isNslType(currentType);
                        String tempType = currentType;
                        if (currentType.indexOf("[") >= 0)
                        {
                            currentType = currentType.substring(0, currentType.indexOf("["));
                        }
                        if (!scope.isPrimitive(tempType))
                        {
                            NslCompiler.parseType(tempType, NslCompiler.libraryDir, scope.getImportList());
                        }
                    }

                    break;
                case 9:
                    indexNum = 0;
                    start = ((SimpleNode) jjtGetChild(i - 1)).getLastToken();
                case 4:
                    indexNodes[indexNum++] = tempNode;
                    state = 4;
                    break;
            }
        }

        if (state == 4)
        {
            if (tempNode != null)
            {
                end = tempNode.getFirstToken();
            }
            currentType = expressionType = getNewType(scope, currentType, indexNum);
            generateIndexCode(start, end, parentExpression, indexNodes, indexNum, scope, currentType);
        }

        return "";
    }

    public String computeType(NslScope scope)
    {

        int childNum = jjtGetNumChildren();

        ASTPrimaryPrefix prefixNode = (ASTPrimaryPrefix) (currentOper = (SimpleNode) jjtGetChild(0));

        int oldState, state;
        String currentType;

        if (prefixNode.isNodeOfType("this"))
        {
            currentType = expressionType = scope.getClassName();
            isAccess = true;
            state = 0;
        }
        else if (prefixNode.isNodeOfType("super."))
        {
            currentType = expressionType = scope.getSuperClassName();
            isAccess = true;
            state = 1;
        }
        else if (prefixNode.isNodeOfType("expression"))
        {
            currentType = expressionType = prefixNode.getType();
            nslExpression = prefixNode.isNslExpression();
            isArray = scope.isArray(expressionType);
            state = 2;
        }
        else if (prefixNode.isNodeOfType("name"))
        {
            currentType = expressionType = prefixNode.getType();
            nslExpression = prefixNode.isNslExpression();
            isArray = scope.isArray(expressionType);
            isMethod = prefixNode.isMethodName();
            state = 3;
        }
        else if (prefixNode.isNodeOfType("literal"))
        {
            expressionType = prefixNode.getType();
            return "";
        }
        else if (prefixNode.isNodeOfType("allocation"))
        {
            expressionType = prefixNode.getType();
            return "";
        }
        else
        {
            return "";
        }

        if (!nslExpression && !isArray && !isMethod && !isAccess)
        {
            return "";
        }

        SimpleNode parentExpression = findParentExpression((SimpleNode) parent);

        if (parentExpression == null)
        {
            NslCompiler.printError("nslc.src.ASTPrimaryExpression", "Compiler bug. An invalid AST was formed");
            return "";
        }

        if (nslExpression && childNum == 1 && state == 3)
        {
            // A Nsl LHS variable
            String ext = (parentExpression.isNodeOfType("assignment") ? ".set(" : "");
            return "";
        }

        int indexNum = 0;
        ASTPrimarySuffix indexNodes[] = new ASTPrimarySuffix[childNum - 1];
        ASTPrimarySuffix tempNode = null;
        Token start = first;
        NslScope methodScope = (isMethod ? prefixNode.getMethodScope() : null);
        String methodName = (isMethod ? prefixNode.getMethodName() : null);
        String[] arguments;
        String variableName;
        for (int i = 1; i < childNum; i++)
        {
            currentOper = tempNode = (ASTPrimarySuffix) jjtGetChild(i);

            oldState = state;
            state = getNextState(oldState, tempNode.getNodeType());
            switch (state)
            {
                case -1:
                    NslCompiler.printError("nslc.src.ASTPrimaryExpression", "Invalid state was reached in expression.", currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                    return "";
                case 7:
                    if (methodScope != null)
                    {
                        arguments = tempNode.getArgumentsTypes();
                        NslMethod method = methodScope.resolveMethod(methodName, arguments);
                        if (method != null)
                        {
                            currentType = expressionType = method.getType();
                            if (i > 1)
                            {
                                ASTPrimarySuffix oldNode = (ASTPrimarySuffix) jjtGetChild(i - 1);
                                oldNode.setType(expressionType);
                                oldNode.setMethod(true);
                            }
                            nslExpression = scope.isNslType(currentType);
                            isArray = scope.isArray(currentType);
                        }
                        else
                        {
                            StringBuilder error = new StringBuilder("Couldn't find method ");
                            error.append(methodScope.getClassName());
                            error.append('.');
                            error.append(methodName);
                            error.append('(');
                            for (int j = 0; j < arguments.length; j++)
                            {
                                error.append(((j > 0) ? ", " : ""));
                                error.append(arguments[j]);
                            }
                            error.append(") in class ");
                            error.append(scope.getClassName());
                            NslCompiler.printError("nslc.src.ASTPrimaryExpression", error.toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        }
                    }
                    else
                    {
                    }
                    break;
                case 8:
                    currentType = expressionType = getNewType(scope, currentType, indexNum);
                    tempNode.setType(expressionType);
                    state = 5;
                case 5:
                    variableName = tempNode.getVariableName();

                    if (currentType.indexOf("[") >= 0)
                    {
                        if (!variableName.equals("length"))
                        {
                            NslCompiler.printError("nslc.src.ASTPrimaryExpression", new StringBuilder("").append("Type ").append(currentType).append(" is an array. Trying to access something different than length").toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        }
                        else
                        {
                            currentType = expressionType = "int";
                            tempNode.setType(expressionType);
                            break;
                        }
                    }
                    NslScope localScope = scope.resolveClass(currentType);

                    if (localScope == null)
                    {
                        NslCompiler.printError("nslc.src.ASTPrimaryExpression", new StringBuilder("").append("Type ").append(currentType).append(" was not found").toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                        return "";
                    }
                    NslVariable temp = localScope.resolveVar(variableName);
                    if (temp == null)
                    {
                        // check if it is a function name
                        NslMethod method = localScope.resolveMethod(variableName);
                        if (method == null)
                        {
                            NslCompiler.printError("nslc.src.ASTPrimaryExpression", new StringBuilder("").append("Variable ").append(variableName).append(" was not found in class ").append(localScope.getClassName()).toString(), currentOper.getFirstToken().beginLine, currentOper.getFirstToken().beginColumn);
                            return "";
                        }
                        else
                        {
                            methodName = variableName;
                            methodScope = localScope;
                            isMethod = true;
                        }
                    }
                    else
                    {
                        currentType = expressionType = temp.getType();
                        tempNode.setType(expressionType);
                        nslExpression = scope.isNslType(currentType);
                        String tempType = currentType;
                        if (currentType.indexOf("[") >= 0)
                        {
                            currentType = currentType.substring(0, currentType.indexOf("["));
                        }
                        if (!scope.isPrimitive(tempType))
                        {
                            NslCompiler.parseType(tempType, NslCompiler.libraryDir, scope.getImportList());
                        }
                    }

                    break;
                case 9:
                    indexNum = 0;
                    start = ((SimpleNode) jjtGetChild(i - 1)).getLastToken();
                case 4:
                    indexNodes[indexNum++] = tempNode;
                    state = 4;
                    break;
            }
        }

        if (state == 4)
        {
            expressionType = getNewType(scope, currentType, indexNum);
            tempNode.setType(expressionType);
        }

        prefixNode.setType(expressionType);

        return "";
    }


    private SimpleNode findParentExpression(SimpleNode node)
    {
        while (true)
        {
            if (node.getClass().getName().equals("nslc.src.ASTExpression") || node instanceof ASTStatementExpression)
            {
                return node;
            }
            else if (node.parent != null)
            {
                node = (SimpleNode) node.parent;
            }
            else
            {
                return null;
            }
        }
    }

}
